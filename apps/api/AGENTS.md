# API Backend — Agent Guidelines

Hono server running on Bun. Functional Core + Imperative Shell.

## Commands

| Task | Command |
|------|---------|
| Dev | `pnpm dev` (or `bun --watch src/main.ts` from this dir) |
| Test | `pnpm test` |
| DB generate | `pnpm db:generate` |
| DB migrate | `pnpm db:migrate` |

## Rules

- **Only `main.ts` may use runtime-specific APIs.** All other code must be isomorphic (no `Bun.*`, no `Deno.*`, no `process.*`).
- Services are pure functions: input → output, no side effects
- Routes use `OpenAPIHono` + `createRoute()` — each endpoint is a contract with request/response schemas
- Import schemas from `@repo/shared`, never redefine them
- Register new slice routes in `src/app.ts` via `app.route()`
- Env vars are validated at startup via `src/env.ts` (Zod schema)

## Route pattern

```typescript
// 1. Define the contract
const myRoute = createRoute({
  method: 'get',
  path: '/{id}',
  tags: ['MySlice'],
  request: { params: idParamSchema },
  responses: {
    200: { content: { 'application/json': { schema: responseSchema } }, description: '...' },
    404: { content: { 'application/json': { schema: errorResponseSchema } }, description: '...' },
  },
})

// 2. Wire the handler
app.openapi(myRoute, async (c) => { ... })
```

## Slice structure

```
src/slices/<name>/
├── schema.ts     ← Drizzle table definition (co-located with slice)
├── routes.ts     ← OpenAPIHono routes with createRoute() contracts
└── service.ts    ← Pure business logic (imports from ./schema)
```

## API endpoints

| Path | Description |
|------|-------------|
| `/api/<slice>` | REST endpoints per slice |
| `/doc` | OpenAPI 3.0 JSON spec (auto-generated) |
| `/ui` | Swagger UI (interactive API explorer) |
| `/health` | Health check (DB + uptime) |

## Database

- ORM: Drizzle with PostgreSQL 18
- Schema per slice: `src/slices/<name>/schema.ts` (co-located with each slice)
- Schema barrel: `src/db/schema.ts` (re-exports all slice schemas for Drizzle client)
- Client: `src/db/client.ts`
- Migrations: `drizzle/` (generated by drizzle-kit)
- Connection: `DATABASE_URL` env var
- **Primary keys: UUIDv7** — use `uuid('id').primaryKey().default(sql\`uuidv7()\`)` (native PG18 function, time-sortable, better B-tree perf than UUIDv4)

## Middleware stack

Middleware executes in this order (defined in `src/app.ts`):

```
Request → requestId → logger → secureHeaders → rateLimiter → cors → [authGuard] → route handler
```

| Middleware | File | Purpose |
|-----------|------|---------|
| `requestId()` | `middleware/request-id.ts` | UUID per request, sets `X-Request-Id` header, accessible via `c.get('requestId')` |
| `honoLogger()` | `@logtape/hono` | Structured request logging via LogTape (method, path, status, duration) |
| `secureHeaders()` | hono built-in | Security headers (X-Content-Type-Options, etc.) |
| `rateLimiter()` | `middleware/rate-limit.ts` | 100 req/min per IP, returns `429` with `Retry-After` |
| `cors()` | hono built-in | Configurable via `CORS_ORIGIN` env var |
| `authGuard()` | `middleware/auth.ts` | JWT (HS256), only active if `JWT_SECRET` is set, excludes `/health` |

## Error handling

**Always use `AppError` from `@repo/shared`.** Never return manual error JSON.

```typescript
import { AppError } from '@repo/shared'

// In services
throw AppError.notFound('Todo not found')
throw AppError.validation('Title is required')
throw AppError.unauthorized('Invalid token')
throw AppError.forbidden('Not your resource')
throw AppError.conflict('Todo already exists')
throw AppError.internal('Unexpected failure')
```

The global error handler in `app.ts` catches all errors and returns:
```json
{ "error": { "code": "NOT_FOUND", "message": "Todo not found", "requestId": "uuid" } }
```

Status codes: `VALIDATION_ERROR`→400, `UNAUTHORIZED`→401, `FORBIDDEN`→403, `NOT_FOUND`→404, `CONFLICT`→409, `RATE_LIMITED`→429, `INTERNAL_ERROR`→500.

## Pagination

All list endpoints must accept `ListQuerySchema` and return paginated responses:

```typescript
import { listQuerySchema, type ListQuery, buildPaginationMeta } from '@repo/shared'

// In createRoute() — add to request.query
request: { query: listQuerySchema }

// In service — apply offset/limit, search, sort
const offset = (query.page - 1) * query.limit
const [items, [{ count }]] = await Promise.all([
  db.select().from(table).offset(offset).limit(query.limit),
  db.select({ count: count() }).from(table),
])

// Return with meta
return { data: items, meta: buildPaginationMeta(query, Number(count)) }
```

## Logging

Uses [LogTape](https://logtape.org) — zero-dependency, cross-runtime structured logging.

- Config: `src/logger.ts` — `setupLogger()` called once in `main.ts`
- Request logging: `@logtape/hono` middleware (`honoLogger()`) in `app.ts`
- App logger: `getAppLogger('module')` returns a categorized logger

```typescript
import { getAppLogger } from '../../logger'

const log = getAppLogger('todos')
log.info('Created todo {id}', { id: todo.id })
log.error('Failed to create: {message}', { message: err.message })
```

LogTape is **silent in tests** (no `setupLogger()` call = no output). Logs appear only in `main.ts` runtime.

## Seed data

`pnpm db:seed` populates the database with sample data for development. The seed script is at `src/db/seed.ts`.

## Environment variables

Validated at startup via `src/env.ts` (Zod schema). App crashes immediately if required vars are missing.

| Variable | Required | Default | Description |
|----------|----------|---------|-------------|
| `DATABASE_URL` | Yes | — | PostgreSQL connection string |
| `API_PORT` | No | 3000 | Server port |
| `CORS_ORIGIN` | No | `http://localhost:5173` | Comma-separated allowed origins |
| `JWT_SECRET` | No | — | Enables JWT auth if set |

## Do NOT

- Use runtime-specific APIs (`Bun.*`, `Deno.*`, `process.*`) outside of `main.ts`
- Import from `@repo/web`
- Put business logic in route handlers
- Use `any` — use Zod inference for types
- Return manual error JSON — use `AppError` factories
- Skip pagination on list endpoints — always use `ListQuerySchema`
- Use `.defaultRandom()` (UUIDv4) for primary keys — always use `.default(sql\`uuidv7()\`)` for time-sorted, index-friendly IDs
