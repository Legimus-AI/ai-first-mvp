# API Backend — Agent Guidelines

Hono server running on Bun. Functional Core + Imperative Shell.

## Commands

| Task | Command |
|------|---------|
| Dev | `pnpm dev` (or `bun --watch src/main.ts` from this dir) |
| Test | `pnpm test` |
| DB generate | `pnpm db:generate` |
| DB migrate | `pnpm db:migrate` |

## Rules

- **Only `main.ts` may use runtime-specific APIs.** All other code must be isomorphic (no `Bun.*`, no `Deno.*`, no `process.*`).
- Services are pure functions: input → output, no side effects
- Routes use `OpenAPIHono` + `createRoute()` — each endpoint is a contract with request/response schemas
- Import schemas from `@repo/shared`, never redefine them
- Register new slice routes in `src/app.ts` via `app.route()`
- Env vars are validated at startup via `src/env.ts` (Zod schema)

## Route pattern

```typescript
// 1. Define the contract
const myRoute = createRoute({
  method: 'get',
  path: '/{id}',
  tags: ['MySlice'],
  request: { params: idParamSchema },
  responses: {
    200: { content: { 'application/json': { schema: responseSchema } }, description: '...' },
    404: { content: { 'application/json': { schema: errorResponseSchema } }, description: '...' },
  },
})

// 2. Wire the handler
app.openapi(myRoute, async (c) => { ... })
```

## Slice structure

```
src/slices/<name>/
├── schema.ts     ← Drizzle table definition (co-located with slice)
├── routes.ts     ← OpenAPIHono routes with createRoute() contracts
└── service.ts    ← Pure business logic (imports from ./schema)
```

## API endpoints

| Path | Description |
|------|-------------|
| `/api/<slice>` | REST endpoints per slice |
| `/doc` | OpenAPI 3.0 JSON spec (auto-generated) |
| `/ui` | Swagger UI (interactive API explorer) |
| `/health` | Health check (DB + uptime) |

## Database

- ORM: Drizzle with PostgreSQL 18
- Schema per slice: `src/slices/<name>/schema.ts` (co-located with each slice)
- Schema barrel: `src/db/schema.ts` (re-exports all slice schemas for Drizzle client)
- Client: `src/db/client.ts`
- Migrations: `drizzle/` (generated by drizzle-kit)
- Connection: `DATABASE_URL` env var
- **Primary keys: UUIDv7** — use `uuid('id').primaryKey().default(sql\`uuidv7()\`)` (native PG18 function, time-sortable, better B-tree perf than UUIDv4)

## Middleware stack

Middleware executes in this order (defined in `src/app.ts`):

```
Request → requestId → logger → secureHeaders → rateLimiter → cors → [authGuard] → route handler
```

| Middleware | File | Purpose |
|-----------|------|---------|
| `requestId()` | `middleware/request-id.ts` | UUID per request, sets `X-Request-Id` header, accessible via `c.get('requestId')` |
| `honoLogger()` | `@logtape/hono` | Structured request logging via LogTape (method, path, status, duration) |
| `secureHeaders()` | hono built-in | Security headers (X-Content-Type-Options, etc.) |
| `rateLimiter()` | `middleware/rate-limit.ts` | 100 req/min per IP, returns `429` with `Retry-After` |
| `cors()` | hono built-in | Configurable via `CORS_ORIGIN` env var |
| `authGuard()` | `middleware/auth.ts` | JWT (HS256), only active if `JWT_SECRET` is set, excludes `/health` |

## Error handling

**Always use `AppError` from `@repo/shared`.** Never return manual error JSON.

```typescript
import { AppError } from '@repo/shared'

// In services
throw AppError.notFound('Todo not found')
throw AppError.validation('Title is required')
throw AppError.unauthorized('Invalid token')
throw AppError.forbidden('Not your resource')
throw AppError.conflict('Todo already exists')
throw AppError.internal('Unexpected failure')
```

The global error handler in `app.ts` catches all errors and returns:
```json
{ "error": { "code": "NOT_FOUND", "message": "Todo not found", "requestId": "uuid" } }
```

Status codes: `VALIDATION_ERROR`→400, `UNAUTHORIZED`→401, `FORBIDDEN`→403, `NOT_FOUND`→404, `CONFLICT`→409, `RATE_LIMITED`→429, `INTERNAL_ERROR`→500.

## Pagination

All list endpoints must accept `ListQuerySchema` and return paginated responses:

```typescript
import { listQuerySchema, type ListQuery, buildPaginationMeta } from '@repo/shared'

// In createRoute() — add to request.query
request: { query: listQuerySchema }

// In service — apply offset/limit, search, sort
const offset = (query.page - 1) * query.limit
const [items, [{ count }]] = await Promise.all([
  db.select().from(table).offset(offset).limit(query.limit),
  db.select({ count: count() }).from(table),
])

// Return with meta
return { data: items, meta: buildPaginationMeta(query, Number(count)) }
```

## Logging

Uses [LogTape](https://logtape.org) — zero-dependency, cross-runtime structured logging.

- Config: `src/logger.ts` — `setupLogger()` called once in `main.ts`
- Request logging: `@logtape/hono` middleware (`honoLogger()`) in `app.ts`
- App logger: `getAppLogger('module')` returns a categorized logger

```typescript
import { getAppLogger } from '../../logger'

const log = getAppLogger('todos')
log.info('Created todo {id}', { id: todo.id })
log.error('Failed to create: {message}', { message: err.message })
```

LogTape is **silent in tests** (no `setupLogger()` call = no output). Logs appear only in `main.ts` runtime.

## Seed data

`pnpm db:seed` populates the database with sample data for development. The seed script is at `src/db/seed.ts`.

## Testing Strategy (Verifier-First)

Three levels of tests, each with clear ownership:

### Level 1: Contract tests (per-slice, generated, no DB, < 100ms)
Verify routes EXIST in OpenAPI spec. Catch missing endpoints or unregistered slices.
File: `src/slices/<name>/__tests__/routes.contract.test.ts`

### Level 2: Integration tests (per-slice, generated stubs, real DB, < 5s)
Test through service layer against PostgreSQL. The generator produces `it.todo()` stubs.
File: `src/slices/<name>/__tests__/routes.integration.test.ts`

### Level 3: Middleware tests (shared, manual, no DB)
Auth, rate-limit, CORS. Written once, not per-slice.
Files: `src/middleware/__tests__/`

### CRUD Test Matrix

Every CRUD slice MUST have tests matching these IDs. The generator scaffolds `it.todo()` stubs.

| Operation | Test ID | Description |
|-----------|---------|-------------|
| **LIST** | LIST-01 | Returns paginated data with default params (page 1, limit 20, desc) |
| | LIST-02 | Respects custom page and limit |
| | LIST-03 | Page 2 returns different items than page 1 |
| | LIST-04 | Page beyond total returns empty data |
| | LIST-05 | Search is case-insensitive and partial match |
| | LIST-06 | Search returns empty for no match |
| | LIST-07 | filterValue + filterFields targets specific columns |
| | LIST-08 | filterFields ignores columns not in whitelist |
| | LIST-09 | Sort ascending works for each sortColumn |
| | LIST-10 | Sort descending works for each sortColumn |
| | LIST-11 | Invalid sort column falls back to defaultSort |
| | LIST-12 | Combined: search + sort + pagination |
| **GET** | GET-01 | Returns item by ID |
| | GET-02 | Returns 404 for non-existent ID |
| **CREATE** | CREATE-01 | Creates and returns item (201) |
| | CREATE-02 | Returns 400 for invalid payload |
| | CREATE-03 | Returns 409 for unique constraint violation (if applicable) |
| **UPDATE** | UPDATE-01 | Updates and returns item |
| | UPDATE-02 | Returns 404 for non-existent ID |
| | UPDATE-03 | Returns 400 for invalid payload |
| | UPDATE-04 | Partial update only changes specified fields |
| **DELETE** | DELETE-01 | Deletes item by ID |
| | DELETE-02 | Returns 404 for non-existent ID |
| **BULK_DELETE** | BULK-01 | Deletes multiple items |
| **CONTRACT** | CONTRACT-01 | All CRUD endpoints exist in OpenAPI spec |

### Test infrastructure

- DB connection: `postgresql://mvp:mvp@localhost:5433/mvp` (Docker)
- Hono test helper: `app.request()` for HTTP tests without running a server
- Vitest with `vitest run` for CI, `vitest` for watch mode
- Tests use real PostgreSQL — no mocks for data layer
- Clean up test data in `afterAll()` — never leave orphan rows

### Test performance budget

| Suite | Target | Current |
|-------|--------|---------|
| Contract tests (all slices) | < 100ms | ~1ms |
| Integration tests (per slice) | < 1s | ~200ms |
| Middleware tests | < 100ms | ~50ms |
| **Full suite** | **< 5s** | **3.7s (87 tests)** |

## Environment variables

Validated at startup via `src/env.ts` (Zod schema). App crashes immediately if required vars are missing.

| Variable | Required | Default | Description |
|----------|----------|---------|-------------|
| `DATABASE_URL` | Yes | — | PostgreSQL connection string |
| `REDIS_URL` | Yes | — | Redis connection string |
| `JWT_SECRET` | Yes | — | JWT signing secret |
| `GEMINI_API_KEY` | Yes | — | Google Gemini API key |
| `API_PORT` | No | 3001 | Server port |
| `CORS_ORIGIN` | No | `http://localhost:5174` | Comma-separated allowed origins |

## Do NOT

- Use runtime-specific APIs (`Bun.*`, `Deno.*`, `process.*`) outside of `main.ts`
- Use `process.env` directly — import typed config from `env.ts`
- Import from `@repo/web`
- Put business logic in route handlers
- Use `any` — use Zod inference for types. Only escape: `biome-ignore` with library name and reason
- Use type assertions (`as any`, `as unknown as T`, `as SomeType`) — use `satisfies` and `as const` instead
- Return manual error JSON — use `AppError` factories
- Skip pagination on list endpoints — always use `ListQuerySchema`
- Use `.defaultRandom()` (UUIDv4) for primary keys — always use `.default(sql\`uuidv7()\`)` for time-sorted, index-friendly IDs
