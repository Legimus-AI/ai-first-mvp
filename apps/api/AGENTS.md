# API Backend — Agent Guidelines

Hono server running on Bun. Functional Core + Imperative Shell.

## Commands

| Task | Command |
|------|---------|
| Dev | `pnpm dev` (or `bun --watch src/main.ts` from this dir) |
| Test | `pnpm test` |
| DB generate | `pnpm db:generate` |
| DB migrate | `pnpm db:migrate` |

## Rules

- **Only `main.ts` may use runtime-specific APIs.** All other code must be isomorphic (no `Bun.*`, no `Deno.*`, no `process.*`).
- Services are pure functions: input → output, no side effects
- Routes use `OpenAPIHono` + `createRoute()` — each endpoint is a contract with request/response schemas
- Import schemas from `@repo/shared`, never redefine them
- Register new slice routes in `src/app.ts` via `app.route()`
- Env vars are validated at startup via `src/env.ts` (Zod schema)

## Route pattern

```typescript
import { AUTH_ERRORS, errorResponses } from '../../lib/openapi-errors'

// 1. Define the contract
const myRoute = createRoute({
  method: 'get',
  path: '/{id}',
  tags: ['MySlice'],
  request: { params: idParamSchema },
  responses: {
    200: { content: { 'application/json': { schema: responseSchema } }, description: '...' },
    ...errorResponses(404),  // Route-specific errors
    ...AUTH_ERRORS,          // Middleware errors (401, 429, 500)
  },
})

// 2. Wire the handler
app.openapi(myRoute, async (c) => { ... })
```

## Error documentation

Routes document ALL possible error responses using per-status schemas with `z.literal()`:

- `errorResponses(400, 404)` — route-specific errors
- `AUTH_ERRORS` — middleware errors for authenticated endpoints (401, 429, 500)
- `PUBLIC_ERRORS` — middleware errors for public endpoints (429, 500)

Import from `../../lib/openapi-errors`. Each status code produces a named OpenAPI component
(e.g., `NotFoundError`, `ValidationError`) with correct example in Swagger UI.

## Slice structure

```
src/slices/<name>/
├── schema.ts     ← Drizzle table definition (co-located with slice)
├── routes.ts     ← OpenAPIHono routes with createRoute() contracts
└── service.ts    ← Pure business logic (imports from ./schema)
```

## API endpoints

| Path | Description |
|------|-------------|
| `/api/<slice>` | REST endpoints per slice |
| `/doc` | OpenAPI 3.0 JSON spec (auto-generated) |
| `/ui` | Swagger UI (interactive API explorer) |
| `/health` | Health check (DB + Redis + uptime) |

## Database

- ORM: Drizzle with PostgreSQL 18
- Schema per slice: `src/slices/<name>/schema.ts` (co-located with each slice)
- Schema barrel: `src/db/schema.ts` (re-exports all slice schemas for Drizzle client)
- Client: `src/db/client.ts`
- Migrations: `drizzle/` (generated by drizzle-kit)
- Connection: `DATABASE_URL` env var
- **Primary keys: UUIDv7** — use `uuid('id').primaryKey().default(sql\`uuidv7()\`)` (native PG18 function, time-sortable, better B-tree perf than UUIDv4)
- **Cleanup:** `closeDb()` available for graceful shutdown (called in `main.ts` SIGTERM/SIGINT handlers)

## Middleware stack

Middleware executes in this order (defined in `src/app.ts`):

```
Request → requestId → logger → secureHeaders → rateLimiter → cors → [authGuard] → route handler
```

| Middleware | File | Purpose |
|-----------|------|---------|
| `requestId()` | `middleware/request-id.ts` | UUID per request, sets `X-Request-Id` header, accessible via `c.get('requestId')` |
| `honoLogger()` | `@logtape/hono` | Structured request logging via LogTape (method, path, status, duration) |
| `secureHeaders()` | hono built-in | Security headers (X-Content-Type-Options, etc.) |
| `rateLimiter()` | `middleware/rate-limit.ts` | 100 req/min per IP, returns `429` with `Retry-After` |
| `cors()` | hono built-in | Configurable via `CORS_ORIGIN` env var |
| `authGuard()` | `middleware/auth.ts` | JWT (HS256), only active if `JWT_SECRET` is set, excludes `/health` and `/api/chat` |

## Error handling

**Always use `AppError` from `@repo/shared`.** Never return manual error JSON.

```typescript
import { AppError } from '@repo/shared'

// In services
throw AppError.notFound('Todo not found')
throw AppError.validation('Title is required')
throw AppError.unauthorized('Invalid token')
throw AppError.forbidden('Not your resource')
throw AppError.conflict('Todo already exists')
throw AppError.internal('Unexpected failure')
```

The global error handler in `app.ts` catches all errors and returns:
```json
{
  "error": {
    "code": "NOT_FOUND",
    "message": "Todo not found",
    "requestId": "uuid",
    "fields": { "title": "Required" }
  }
}
```

Status codes: `VALIDATION_ERROR`→400, `UNAUTHORIZED`→401, `FORBIDDEN`→403, `NOT_FOUND`→404, `CONFLICT`→409, `RATE_LIMITED`→429, `INTERNAL_ERROR`→500.

The `fields` object is included for validation errors (400) and contains field-level error messages extracted from ZodError.

## Pagination

All list endpoints must accept `ListQuerySchema` and return paginated responses.

### Using paginatedList() helper

**ALWAYS use `paginatedList()` from `src/lib/query-utils.ts`.** This reduces ~30 lines of boilerplate to ~5 lines.

```typescript
import { type ListQuery } from '@repo/shared'
import { paginatedList } from '../../lib/query-utils'
import { myTable } from './schema'

export async function listItems(query: ListQuery) {
  const db = getDb()
  return paginatedList(db, query, {
    table: myTable,
    searchColumns: [myTable.name, myTable.description],  // General search fields
    sortColumns: {                                       // Whitelist for sort & filter
      name: myTable.name,
      createdAt: myTable.createdAt,
      updatedAt: myTable.updatedAt,
    },
    defaultSort: 'createdAt',
    extraWhere: eq(myTable.botId, botId),  // Optional: scope by foreign key
  })
}
```

### Query parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `page` | number | Page number (1-indexed) |
| `limit` | number | Items per page (1-100, default 20) |
| `search` | string | General search across `searchColumns` |
| `filterValue` | string | Targeted search value |
| `filterFields` | string | Comma-separated column names (resolved against `sortColumns` whitelist) |
| `sort` | string | Column name (must exist in `sortColumns`) |
| `order` | 'asc'\|'desc' | Sort direction (default 'desc') |

### Filter patterns

**General search:** `?search=laptop` searches across all `searchColumns`

**Targeted search:** `?filterValue=51983724476&filterFields=phone,email` searches only specified columns (resolved against `sortColumns` whitelist for security)

### Security

- `sortColumns` is a **whitelist** — user input for `sort` and `filterFields` is resolved against this map
- User strings never reach SQL — prevents SQL injection
- Only columns in the whitelist can be sorted or filtered

## External services

External service integrations live in `src/lib/`. Each service is a thin wrapper that:
1. Exports pure functions (no classes, no singletons)
2. Accepts configuration via parameters (not global state)
3. Is initialized in `main.ts` and passed to handlers via closure or context

### Adding a new external service

1. Create `src/lib/<service-name>.ts` — thin wrapper with typed functions
2. Add env vars to `src/env.ts` (Zod validates at startup)
3. Initialize in `src/main.ts`
4. Create `src/lib/__tests__/<service-name>.test.ts` — mock-based tests

### File structure

```
src/lib/
├── query-utils.ts        ← DB utilities (internal)
├── <service-name>.ts     ← External service wrapper
└── __tests__/
    └── <service-name>.test.ts  ← Mock-based tests
```

### Pattern

```typescript
// src/lib/stripe.ts — Example external service
import Stripe from 'stripe'

let _client: Stripe | null = null

export function initStripe(apiKey: string) {
  _client = new Stripe(apiKey)
  return _client
}

export function getStripe() {
  if (!_client) throw new Error('Stripe not initialized. Call initStripe() first.')
  return _client
}

// Pure function wrappers — easy to mock in tests
export async function createCheckoutSession(priceId: string, customerId: string) {
  const stripe = getStripe()
  return stripe.checkout.sessions.create({
    mode: 'subscription',
    customer: customerId,
    line_items: [{ price: priceId, quantity: 1 }],
    success_url: 'https://example.com/success',
    cancel_url: 'https://example.com/cancel',
  })
}
```

### Testing with mocks

```typescript
// src/lib/__tests__/stripe.test.ts
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { createCheckoutSession } from '../stripe'

// Mock the module
vi.mock('stripe', () => ({
  default: vi.fn().mockImplementation(() => ({
    checkout: {
      sessions: {
        create: vi.fn().mockResolvedValue({ id: 'cs_test_123', url: 'https://checkout.stripe.com/...' }),
      },
    },
  })),
}))

describe('stripe', () => {
  beforeEach(() => {
    // Initialize with test key
    const { initStripe } = require('../stripe')
    initStripe('sk_test_fake')
  })

  it('creates checkout session', async () => {
    const session = await createCheckoutSession('price_123', 'cus_456')
    expect(session.id).toBe('cs_test_123')
  })
})
```

### Env vars for external services

```typescript
// src/env.ts — add new service keys
const envSchema = z.object({
  DATABASE_URL: z.string().url(),
  // ... existing vars ...
  STRIPE_SECRET_KEY: z.string().optional(),  // Optional = feature flag
  STRIPE_WEBHOOK_SECRET: z.string().optional(),
})
```

Optional env vars act as feature flags — if `STRIPE_SECRET_KEY` is not set, the service is not initialized.

### Initialization in main.ts

```typescript
// src/main.ts
import { initStripe } from './lib/stripe'

if (env.STRIPE_SECRET_KEY) {
  initStripe(env.STRIPE_SECRET_KEY)
  log.info('Stripe initialized')
}
```

### Rules

- **No classes** — use init/get pattern (like `initDb`/`getDb`)
- **No global imports** — always go through the getter function
- **Optional services** — use optional env vars as feature flags
- **Thin wrappers** — don't abstract the SDK, just wrap the calls you use
- **Pure functions** — each exported function does ONE thing
- **Mock at module level** — use `vi.mock()` to replace the SDK in tests

## Logging

Uses [LogTape](https://logtape.org) — zero-dependency, cross-runtime structured logging.

- Config: `src/logger.ts` — `setupLogger()` called once in `main.ts`
- Request logging: `@logtape/hono` middleware (`honoLogger()`) in `app.ts`
- App logger: `getAppLogger('module')` returns a categorized logger

```typescript
import { getAppLogger } from '../../logger'

const log = getAppLogger('todos')
log.info('Created todo {id}', { id: todo.id })
log.error('Failed to create: {message}', { message: err.message })
```

LogTape is **silent in tests** (no `setupLogger()` call = no output). Logs appear only in `main.ts` runtime.

## Seed data

`pnpm db:seed` populates the database with sample data for development. The seed script is at `src/db/seed.ts`.

## Graceful shutdown

The server handles SIGTERM and SIGINT signals for graceful shutdown (configured in `main.ts`):

1. Receives signal (SIGTERM from Docker/Kubernetes, SIGINT from Ctrl+C)
2. Logs shutdown start
3. Closes database connections via `closeDb()`
4. Logs shutdown complete
5. Exits with code 0

This ensures no in-flight queries are interrupted and connection pools are properly drained.

## Testing Strategy (Verifier-First)

Three levels of tests, each with clear ownership:

### Level 1: Contract tests (per-slice, generated, no DB, < 100ms)
Verify routes EXIST in OpenAPI spec. Catch missing endpoints or unregistered slices.
File: `src/slices/<name>/__tests__/routes.contract.test.ts`

### Level 2: Integration tests (per-slice, generated stubs, real DB, < 5s)
Test through service layer against PostgreSQL. The generator produces `it.todo()` stubs.
File: `src/slices/<name>/__tests__/routes.integration.test.ts`

### Level 3: Middleware tests (shared, manual, no DB)
Auth, rate-limit, CORS. Written once, not per-slice.
Files: `src/middleware/__tests__/`

### CRUD Test Matrix

Every CRUD slice MUST have tests matching these IDs. The generator scaffolds `it.todo()` stubs.

| Operation | Test ID | Description |
|-----------|---------|-------------|
| **LIST** | LIST-01 | Returns paginated data with default params (page 1, limit 20, desc) |
| | LIST-02 | Respects custom page and limit |
| | LIST-03 | Page 2 returns different items than page 1 |
| | LIST-04 | Page beyond total returns empty data |
| | LIST-05 | Search is case-insensitive and partial match |
| | LIST-06 | Search returns empty for no match |
| | LIST-07 | filterValue + filterFields targets specific columns |
| | LIST-08 | filterFields ignores columns not in whitelist |
| | LIST-09 | Sort ascending works for each sortColumn |
| | LIST-10 | Sort descending works for each sortColumn |
| | LIST-11 | Invalid sort column falls back to defaultSort |
| | LIST-12 | Combined: search + sort + pagination |
| **GET** | GET-01 | Returns item by ID |
| | GET-02 | Returns 404 for non-existent ID |
| **CREATE** | CREATE-01 | Creates and returns item (201) |
| | CREATE-02 | Returns 400 for invalid payload |
| | CREATE-03 | Returns 409 for unique constraint violation (if applicable) |
| **UPDATE** | UPDATE-01 | Updates and returns item |
| | UPDATE-02 | Returns 404 for non-existent ID |
| | UPDATE-03 | Returns 400 for invalid payload |
| | UPDATE-04 | Partial update only changes specified fields |
| **DELETE** | DELETE-01 | Deletes item by ID |
| | DELETE-02 | Returns 404 for non-existent ID |
| **BULK_DELETE** | BULK-01 | Deletes multiple items |
| **CONTRACT** | CONTRACT-01 | All CRUD endpoints exist in OpenAPI spec |

### Test infrastructure

- DB connection: `postgresql://mvp:mvp@localhost:5433/mvp` (Docker)
- Hono test helper: `app.request()` for HTTP tests without running a server
- Vitest with `vitest run` for CI, `vitest` for watch mode
- Tests use real PostgreSQL — no mocks for data layer
- Clean up test data in `afterAll()` — never leave orphan rows

### Test performance budget

| Suite | Target | Current |
|-------|--------|---------|
| Contract tests (all slices) | < 100ms | ~1ms |
| Integration tests (per slice) | < 1s | ~200ms |
| Middleware tests | < 100ms | ~50ms |
| **Full suite** | **< 5s** | **1.1s (165 tests)** |

## Environment variables

Validated at startup via `src/env.ts` (Zod schema). App crashes immediately if required vars are missing.

| Variable | Required | Default | Description |
|----------|----------|---------|-------------|
| `DATABASE_URL` | Yes | — | PostgreSQL connection string |
| `REDIS_URL` | Yes | — | Redis connection string |
| `JWT_SECRET` | Yes | — | JWT signing secret |
| `GEMINI_API_KEY` | Yes | — | Google Gemini API key |
| `API_PORT` | No | 3001 | Server port |
| `CORS_ORIGIN` | No | `http://localhost:5174` | Comma-separated allowed origins |

## Database Safety

### Migration Rules

- **Migrations are IMMUTABLE.** Never edit, rename, or delete a migration file in `drizzle/` that has been generated. If a migration is wrong, generate a NEW migration that corrects it.
- **Review before commit.** After `pnpm db:generate`, always inspect `git diff drizzle/` before committing. Never auto-commit migrations without reviewing the generated SQL.
- **No DROP TABLE or DROP COLUMN.** If Drizzle generates a `DROP`, the schema change is wrong. Use expand-contract: add new column/table → migrate data → deprecate old → remove in a future migration after verification.
- **No `drizzle-kit push` in production.** Push auto-syncs schema without migration files — it can silently drop tables. Production uses only versioned migrations via `pnpm db:migrate`.

### Data Safety

- **No DELETE/UPDATE without WHERE.** Bulk `DELETE FROM table` or `UPDATE table SET ...` without a `WHERE` clause is forbidden in application code. The ONLY exception is test cleanup in `afterAll()`.
- **Seed ≠ Migration.** Seeds (`db:seed`) insert dev data and must be idempotent. Migrations change schema structure. Never mix data manipulation (INSERT/DELETE) into migration files.
- **Destructive operations = ask human.** If a task requires dropping tables, truncating data, resetting schemas, or modifying existing migration files — STOP and ask for explicit confirmation. Never take destructive database actions autonomously.

### Credentials

- **No hardcoded credentials.** All secrets (DATABASE_URL, API keys, tokens) come from `env.ts` (Zod-validated). Never write connection strings or credentials in source code, tests, or seed files.
- **`.env` files are gitignored.** Never commit `.env` files. Use `.env.example` with placeholder values for documentation.

## Do NOT

- Use runtime-specific APIs (`Bun.*`, `Deno.*`, `process.*`) outside of `main.ts`
- Use `process.env` directly — import typed config from `env.ts`
- Use type assertions (`as any`, `as unknown as T`, `as SomeType`) — use `satisfies` and `as const` instead
- Import from `@repo/web`
- Put business logic in route handlers
- Use `any` — use Zod inference for types. Only escape: biome-ignore with library name and reason
- Return manual error JSON — use `AppError` factories
- Skip pagination on list endpoints — always use `ListQuerySchema`
- Use `.defaultRandom()` (UUIDv4) for primary keys — always use `.default(sql\`uuidv7()\`)` for time-sorted, index-friendly IDs
- Edit or delete migration files in `drizzle/` — they are immutable
- Run `drizzle-kit push` against production — use `db:migrate` only
- Execute `DELETE`/`UPDATE` without `WHERE` — except in test cleanup
